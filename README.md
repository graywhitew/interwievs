# Python
- Какие бывают типы данных в Python?

  | Неизменяемые | изменяемые |
  | ---------- | ------------ |
  | int, float, str, bool, NoneType, turple, frozenset| list, set, dict|  
```python
some_string = "12345"
some_string[2] = "7"
print(some_string)
>>>TypeError: 'str' object does not suppurt item assigment
```
  
- Чем отличается операторы == и is?

== сравнивает два операнда по значениям,  
is по адресам в памяти

- Как в python передаются аргументы в функцию?

Аргументы функции передеются либо по значениям (неизменяемые), либо по ссылкам (изменяемые)
```python
def some_function(some_arg: list = []):
  some_arg.append(1)
  return some_arg
for _ in range(5):
  print(some_function())
>>>[1]
>>>[1,1]
>>>[1,1,1]
>>>[1,1,1,1]
>>>[1,1,1,1,1]
```
- Что такое args и kwargs? Чем представлены?

*args - аргумент принимающий в себя неограниченное количество позиционных аргументов функции. Представлен в виде кортежа(turple).  
**kwargs - аргумент принимающий в себя неограниченное количество именнованных аргументов функции. Представлен в виде словаря(dict).
Необязательно их называть именно так, просто так принято для читаемости.

- Что такое аннотации типов, зачем они нужны, когда выполняются?

Объявление типов параметров функции и их возвращаемых значений. Не вляет на выполнение работы программы, подскзки для большей читаемости кода и других программистов,
но в современных IDE при передаче неправильных типов показывается ошибка.
```python
def some_function(some_arg: list = []):
```

- Что такое lambda функция? Кейсы применения.

Псевдо-функция (аннонимная) принимает неог. количество аргументов, содержащая неявный return. Часто спользуется в filter, map, sorting и т.д..
```python
some_list = [0,1,2,3,4,7,-1,-5,10,18]
print(list(filter(lambda x: x > 5, some_list)))
```

- Что такое тернарный оператор, как записывается?

Тернарный оператор - это if который записывается в одну строчку.
```python
some_ans = True
some_arg = 1 if some_ans else 0 
```

- Что такое глубокая и поверхностная копия? Зачем нужны? Как их сделать?

Поверхностная копия - это такая копия, что мы внешний объект скопируем, получим новый адрес памяти, а всё что внутри попытается сохранить ссылками.
```python
import copy

some_list = [1,2,[3],4]

print(some_list is copy.copy(some_list))
>>> False
print(some_list[1] is copy.copy(some_list)[1])
>>> True
print(some_list[2] is copy.deepcopy(some_list)[2])
>>> False
```
- Что такое виртуальное окружение? Зачем оно нужно? Какие инструменты для этого используются?
  
При написании нескольких проектов могут пригодиться разные библиотеки, и чтобы из разных проектов библиотеки их зависимости не конфликтовали друг с другом, создаётся отдельное окружение для каждого проекта, где будут только библиотеки нужные под данный проект.
Так же можно делать отдельное виртуальное окружение для конкретной версии питона.

- Что такое Poetry? Использовал ли ты его? Какие преимущества?

Есть стандартная встроенная библиотека pip для управления зависимостями, Poetry - тоже самое только от сторонних разработчиков с большим функционалом и удобнее.
Могут задать вопрос, откуда при установке библиотек мы их тянем - pip берёт покеты с pypip.org
Что за файл requirements.txt - в нём прописываются все зависимости проекта, потом можно pip install -r и установить все зависимости для проекта, чтобы быстро его развернуть.

- Как оценивается сложность алгоритмов и почему? Что такое Big O notation?

Сложность алгоритмов оценивается с помощью Big O notation, из за того что метрика в секундах не подходит, ибо скорость выполнения программы зависит от железа,
поэтому оценивается математическая зависимость времени выполнения от выполняемых операций.
Если просто нужно пройти по колеекции - n
Если нужно пройти рекурсивно - log n
Если цикл в цикле - n * n

- Какая сложность основных операций в коллекциях?

Где будет быстрее вставка, удаление, поиск?
Удаление в списках и словарях быстрее.
Прохождение O(n)
Почему?
```python
print(2 in [1,2,3]) #О(n) 
print(2 in {1,2,3}) #O(1)
#Быстрее будет в set ибо список предствлен в виде массива с указателем, а в set в виде хэш таблицы
```

- Что такое хеш-таблица? Что такое коллизия? Какие методы коллизии бывают, и какой используется в Python?
   
set или dict - это под бэкендом хэш-таблица. Хэш-таблица это такая структура данных где у нас есть уникальный хэш, который образутеся с помощью хэш-функций и ссылается на какие то значения, которые хранятся в оперативной памяти. Если у некоторых данных совпадают хэши - то это называют коллизией.
Существуют различные методы разрешения коллизии:
Метод цепочек - берём один хэш, который ссылатеся на данные, мы эти данные выстраиваем в виде списка, проходимся по списку и смотрим, есть ли там такой хэш.
Метод линейного разрешения коллизии - хеши расставляем по таблице на каком то линейном расстоянии.
Метод квадратичного пробивания - каждый раз увеличиваем хэш, который нам надо вставить в таблицу, на степень двойки.
Метод двойного хеширования - брем хэш от хэша
В питоне метод квадратичного пробивания.

- Что такое self в классах?  

В питоне чтобы в функции мы понимали к какому объекту она относится, методы объекта первым оргументом принимают self. self - ссылка на текущий созданный уникальный объект какого-то класса, чтобы мы понимали в каком объекте вносить изменения или брать данные.

- Зачем нужен метод super в классах?  

Нужен для доступа к родительским классам , когда у нас есть наследование, т.е. к родительским функциям, когда дочерняя может быть перегружена. Это условно ссылка на объект родительской сущности. Часто используется в магических методах типа __init__.

- Как в Python реализуется методы объекта, класса и статические методы? Чем они отличаются?  
```python
class A: #класс
  def a(self): #метод объекта, self - ссылка на текщий объект, характеризует поведения экземпляра сущности
    pass

  @classmetod
  def b(cls): #метод класса, cls - ссылка на класс, характеризует поведение класса, и может вызываться без создания объекта класса
    pass

  @staticmethod
  def c(): #принимает то что надо, не принадлежит не к классу не к объекту, но подходит по смыслу, и может вызываться без создания объекта класса
    pass

a = A()

a.a()

A.b()
A.c()
```

- В Python нет модификаторов доступа, все по умолчанию public. Как в python реализуется public, private и protected методы и аттрибуты.  

Все аттрибуты по умолчанию являются public, если аттрибут хотим видеть как protected то пишем название переменной через _, private аттрибуты пишутся через два _.
