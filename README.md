# Python
- Какие бывают типы данных в Python?

  | Неизменяемые | изменяемые |
  | ---------- | ------------ |
  | int, float, str, bool, NoneType, turple, frozenset| list, set, dict|  
```python
some_string = "12345"
some_string[2] = "7"
print(some_string)
>>>TypeError: 'str' object does not suppurt item assigment
```
  
- Чем отличается операторы == и is?
> == сравнивает два операнда по значениям,  
is по адресам в памяти

- Как в python передаются аргументы в функцию?

> Аргументы функции передеются либо по значениям (неизменяемые), либо по ссылкам (изменяемые)
```python
def some_function(some_arg: list = []):
  some_arg.append(1)
  return some_arg
for _ in range(5):
  print(some_function())
>>>[1]
>>>[1,1]
>>>[1,1,1]
>>>[1,1,1,1]
>>>[1,1,1,1,1]
```
- Что такое args и kwargs? Чем представлены?

> *args - аргумент принимающий в себя неограниченное количество позиционных аргументов функции. Представлен в виде кортежа(turple).  
**kwargs - аргумент принимающий в себя неограниченное количество именнованных аргументов функции. Представлен в виде словаря(dict).
Необязательно их называть именно так, просто так принято для читаемости.

- Что такое аннотации типов, зачем они нужны, когда выполняются?

> Объявление типов параметров функции и их возвращаемых значений. Не вляет на выполнение работы программы, подскзки для большей читаемости кода и других программистов,
но в современных IDE при передаче неправильных типов показывается ошибка.
```python
def some_function(some_arg: list = []):
```

- Что такое lambda функция? Кейсы применения.

> Псевдо-функция (аннонимная) принимает неог. количество аргументов, содержащая неявный return. Часто спользуется в filter, map, sorting и т.д..
```python
some_list = [0,1,2,3,4,7,-1,-5,10,18]
print(list(filter(lambda x: x > 5, some_list)))
```

- Что такое тернарный оператор, как записывается?

> Тернарный оператор - это if который записывается в одну строчку.
```python
some_ans = True
some_arg = 1 if some_ans else 0 
```

- Что такое глубокая и поверхностная копия? Зачем нужны? Как их сделать?

> Поверхностная копия - это такая копия, что мы внешний объект скопируем, получим новый адрес памяти, а всё что внутри попытается сохранить ссылками.
```python
import copy

some_list = [1,2,[3],4]

print(some_list is copy.copy(some_list))
>>> False
print(some_list[1] is copy.copy(some_list)[1])
>>> True
print(some_list[2] is copy.deepcopy(some_list)[2])
>>> False
```
- Что такое виртуальное окружение? Зачем оно нужно? Какие инструменты для этого используются?
  
> При написании нескольких проектов могут пригодиться разные библиотеки, и чтобы из разных проектов библиотеки их зависимости не конфликтовали друг с другом, создаётся отдельное окружение для каждого проекта, где будут только библиотеки нужные под данный проект.
Так же можно делать отдельное виртуальное окружение для конкретной версии питона.

- Что такое Poetry? Использовал ли ты его? Какие преимущества?

> Есть стандартная встроенная библиотека pip для управления зависимостями, Poetry - тоже самое только от сторонних разработчиков с большим функционалом и удобнее.
Могут задать вопрос, откуда при установке библиотек мы их тянем - pip берёт покеты с pypip.org
Что за файл requirements.txt - в нём прописываются все зависимости проекта, потом можно pip install -r и установить все зависимости для проекта, чтобы быстро его развернуть.

- Как оценивается сложность алгоритмов и почему? Что такое Big O notation?

> Сложность алгоритмов оценивается с помощью Big O notation, из за того что метрика в секундах не подходит, ибо скорость выполнения программы зависит от железа,
поэтому оценивается математическая зависимость времени выполнения от выполняемых операций.
Если просто нужно пройти по колеекции - n
Если нужно пройти рекурсивно - log n
Если цикл в цикле - n * n

- Какая сложность основных операций в коллекциях?

> Где будет быстрее вставка, удаление, поиск?
Удаление в списках и словарях быстрее.
Прохождение O(n)
Почему?
```python
print(2 in [1,2,3]) #О(n) 
print(2 in {1,2,3}) #O(1)
#Быстрее будет в set ибо список предствлен в виде массива с указателем, а в set в виде хэш таблицы
```

- Что такое хеш-таблица? Что такое коллизия? Какие методы коллизии бывают, и какой используется в Python?
   
> set или dict - это под бэкендом хэш-таблица. Хэш-таблица это такая структура данных где у нас есть уникальный хэш, который образутеся с помощью хэш-функций и ссылается на какие то значения, которые хранятся в оперативной памяти. Если у некоторых данных совпадают хэши - то это называют коллизией.
Существуют различные методы разрешения коллизии:
Метод цепочек - берём один хэш, который ссылатеся на данные, мы эти данные выстраиваем в виде списка, проходимся по списку и смотрим, есть ли там такой хэш.
Метод линейного разрешения коллизии - хеши расставляем по таблице на каком то линейном расстоянии.
Метод квадратичного пробивания - каждый раз увеличиваем хэш, который нам надо вставить в таблицу, на степень двойки.
Метод двойного хеширования - брем хэш от хэша
В питоне метод квадратичного пробивания.

- Что такое self в классах?  

> В питоне чтобы в функции мы понимали к какому объекту она относится, методы объекта первым оргументом принимают self. self - ссылка на текущий созданный уникальный объект какого-то класса, чтобы мы понимали в каком объекте вносить изменения или брать данные.

- Зачем нужен метод super в классах?  

> Нужен для доступа к родительским классам , когда у нас есть наследование, т.е. к родительским функциям, когда дочерняя может быть перегружена. Это условно ссылка на объект родительской сущности. Часто используется в магических методах типа __init__.

- Как в Python реализуется методы объекта, класса и статические методы? Чем они отличаются?  
```python
class A: #класс
  def a(self): #метод объекта, self - ссылка на текщий объект, характеризует поведения экземпляра сущности
    pass

  @classmetod
  def b(cls): #метод класса, cls - ссылка на класс, характеризует поведение класса, и может вызываться без создания объекта класса
    pass

  @staticmethod
  def c(): #принимает то что надо, не принадлежит не к классу не к объекту, но подходит по смыслу, и может вызываться без создания объекта класса
    pass

a = A()

a.a()

A.b()
A.c()
```

- В Python нет модификаторов доступа, все по умолчанию public. Как в python реализуется public, private и protected методы и аттрибуты.  

> Все аттрибуты по умолчанию являются public, если аттрибут хотим видеть как protected то пишем название переменной через _, private аттрибуты пишутся через два _.

```python
class A:
  _some_val = 0 #protected 
  __some_val = 0 #private
  def a(self):
    pass

a = A()

a._some_val #вызов protected аттрибута
a._A__some_val #вызов private аттрибута
#В современных IDE будет уведомление о том что такие аттрибуты вам не стоит использовать.
```
- Что такое декораторы? Зачем нужны? Как реализовать в python простой декоратор и декоратор с пробросом аргумента?  
> __Декоратор__ - это паттерн проектирования реализующийся по канону через класс. С помощью этого классе меняется поведение кода без изменения исходного кода. В Python функции объекты первого класса, функция может принимать функцию и возвращать другую функцию в качестве ответа.  Декоратор это замыкание.
```python
def decorator(func):
  def wrapper(*args, **kwargs):
    result = func(*args, **kwargs)
    return result
  return wrapper

@decorator #<- использование "синтаксического сахара"
def some():
  pass

def some2():
  pass

some_2_with_dec = decorator(some_2) #<- использование без "синтаксического сахара"
print(some_2_with_dec)
>>><function decorator.<locals>.wrapper at 0x000001A2CD889E40>
#если хотим вывод через сигнатуру, то можем использовать встроенный декоратор @wraps(func), внутри декоратора перед функцией wrapper (не забудь импортировать from functools import wraps)
```
> Декоратор с пробрешенным аргументом
```python
def outer(a = 1):
  def decorator(func):
    def wrapper(*args, **kwargs):
      result = func(*args, **kwargs)
      return result
    return wrapper
  return decorator

@outer(123) #<- использование "синтаксического сахара"
def some():
  pass

def some2():
  pass

dec = outer(123)
some_with_dec = dec(some_2) #<- использование без "синтаксического сахара"
```

- Что такое абстрактный класс? Зачем они нужны? Как они реализуются в Python?  
> __Абстрактный класс__ - класс у которого нельзя создать объект. Нужен для написания контракта, которые должны реализовать дочернии классы, через абстрактные методы.
```python
from abc import ABC, abstractmethod

class A(ABC):
  @abstractmethod
  def some():
    pass

class B(A): # <- будет абстрактным пока мы не переопределим все абстрактные методы, только тогда можно будет создать объекты этого класса
  def some():
    pass
```
- Что такое метаклассы? Для чего они используются? Какие методы там используются? Как реализовать на Python?
> __Метаклассы__ - шаблоны для классов, на основе которых строются классы. Метаклассы -> Классы -> Объекты. Используются для того чтобы перехватить создания классов, и его как то изменить либо изменить его поведение, создание объекта и т.д.. В метаклассах испольуют 4 метода: __new__, __init__, __prepare__, __call__.  
> __prepare__ - подготавливает данные  
> __new__ - создаёт класс  
> __init__ - отвечает за его инициализацию  
> __call__ - отвечает за создание объекта класса  
> В 99% случиях в мета классах просто переопределяется метод __new__, потому что как правило нам интересно поменять какие то методы, аттрибуты.
```python
from abc import ABC, abstractmethod, ABCMeta

class OneMeta(ABCMeta): #если хотим, чтобы из этого метакласса получался какой то абстрактный класс
  pass


class Two(type): #если просто хотим метакласс, type - типовой метакласс
  def __new__(msc, name, bases, attrs):
```

- Что такое ООП?  
> _ООП_ - парадигма объектно-ориентированного программирования, когда мы код выстраиваем в виде совокупности объектов, которые являются объектами каких то классов, а классы выстраивают иерархию насследования. Базовые парадигмы:  
> __Абстракция__ - говорит о том что в коде используем только те характеристики объекта, которые важны только в данном коде.  
> __Наследование__ - один класс может строиться на основе другого класса, один будет родительским другой дочерним, дочерний класс получает ВСЁ от родительского (все аттрибуты все методы)  
> __Инкапсуляция__ - понимается двояко. Первый фундаментально инкапсуляция - in capsule, в класс мы должны поместить все методы и аттрибуты, которые связаны общей идеей. Второй про сокрытие данных, в классе у нас должны быть private и protected аттрибуты, ничего не должно выходить лишнего наружу и пользователь должен иметь доступ только к тому функционалу с которым он должен работать, ничего лишнего.  
> __Полиморфизм__ - понимается двояко. каноничный подход - параметрический палиморфизм("утинная типизация"), нам плевать какие типы арнгументов мы принимаем, главное чтобы с этим аргументом внутри функции реализовались весь рабочий интерфейс. Второй подход (Бьёрн Страуструп) - у нас есть наследвание, родительский и дочерний класс, полиморфизм представляет из себя то, что мы используем одни и те же имена, во всей этой структуре за счёт того что мы можем в дочерних перегружать родительские методы, тем самым модифицируя их функционал.  

- Что такое миксины?  
> Каноническое наследование говорит о том что у нас есть дочерний класс и родительский, дочерний берёт все от родительского, но если брать по смыслу дочерний класс - родительский, миксины ломают эту парадигму, т.к. __миксины__ - мелкие классы, которые реализуют небольшой функционал, но данный функционал нужен во многих классах, поэтому мы можем в этих классах просто наследовать Minin(примеси)  

- Что такое diamond problem? Что такое MRO? Чем отличается MRO2 от MRO3? Зачем оно нужно?  
> _diamond problem_ - Python поддерживает множественное наследование, т.е. когда класс наследует нексколько родительских классов, и сам Python не знает в каком порядке правильно построить зависимости и пройтись по конструкторам. Поэтому в Python реализован такой метод как MRO - Method resolution problem, который говорит говорит что в пайтоне есть опеределенный поряд наследования. MRO2 - этом етод из Python2, в котором этот метод реализовался через __поиск в глубину__, а в MRO3, который используется в Python3 используется __поиск в ширину__. Сам по себе MRO - это список, который можно вызвать __print(Class.mro)__

- Что такое итератор? Что такое итерируемый объект?
> Итератор - такая структура данных которая может отдавать что либо по отдельности, т.е. итерируемый объект - такой объект по которому можно пройти по-элементно. В Pyrhon итератор реализуется с помощью двух методов класса:
> __iter__ - возвращает ссылку на итератор
> __next__ - возвращает следуйщий объект этой последовательности  
> Их два т.к. их можно отнести к двум отдельным классам, в одном классе будет только итер и в другом только некст

- Что такое генератор? Как написать на Python генератор?
> __Генератор__ - такая функция, у которой вместо return используется yield, это такая вещь, которая умеет принимать и отдавать контроль управления, от yield к yield будем получать следующие объекты генератора. У генератора плюс в том что он в отличии от обычной функции не забывает, что происходило в последнем yield. Чтобы работать с генератором, нужно выполнить генераторную функцию, получить объект генератора и дальше с помощью __next__ получать следуйщие элекменты данной последовательности, когда yield закочится получим "StopIteration".
```python
a = (i**2 for i in range(1,5))
print(a)
>>> <generator object <genexpr> at 0x0000023A7524D6D0>
next(a)
>>> 1
next(a)
>>> 4
next(a)
>>> 9
next(a)
>>> 16
next(a)
>>> Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
```python
a = (i**2 for i in range(1,5))
for i in a:
  print(i)
>>> 1
>>> 4
>>> 9
>>> 16
```
> Используются, когда возможно переполнение памяти. Ещё три метода, кроме __next__:  
> .close () — останавливает выполнение генератора;  
> .throw () — генератор бросает исключение;  
> .send () — интересный метод, позволяет отправлять значения генератору.  

- Что такое корутина?
> __Корутина__ - генератор, к которому мы добавляем возможность не только отдавать следуйщий элемент, но и ещё посылать данные с помощью __.send()__, тогда yield будет находиться не слева, а справа.

- Что такое async и await?
> Для выполнения паралельного и конкурентного кода используются библиотеки:  
> __threading__ - в рамках одного процесса делим потоки, у потоков есть общая память, где они конкурентно выполяются и нужно ставить блокировки, чтобы они с общей памятью безопасно работали.  
> __multiprocessing__ - программу можем запускать в различных процессах, которые друг от друга не зависят, нужна архитектура в виде многоядерного процесса.  
> __asyncio__ - событиный цикл(event_loop), проходящий по __task__(корутинам) опрашивает их на выполнение и взависимости от ответа, между ними переключается.  
> Когда что использовать? Если ждём выполнение задачи от ЦПУ, то используем __multiprocessing__. Ждём ввод вывод то __threading__ или __asyncio__, если быстрый ввод вывод или Python староват, то выбираем __threading__, а если Python 3.6+ и ввод-вывод медленный то __asyncio__.


- Что такое GIL? Какие проблемы он решает?
> __GIL__ - Global Interpreter Lock, блокирует интерпритатор на то, что у нас может исполняться только один поток. Позволяет интегрировать в Python C-расширения и безопасно управлять памятью, и программы в однопотоке быстрые.  

- Какие модули в Python есть для тестирования? Какие отличия, плюсы и минусы?
> Тесты писать нужно всегда, как минимум __Unittest__, потому что они самые дешёвые, ими должно быть покрыто ~100% кода. Виды текстов:  
> __Unittest__ - тестирует какой то мелкий функционал - класс, функцию, минимальный блок функционирующего кода.  
> Функциональный - тестирует связку компонентов (пакеты, endpoint).  
> Интерграционный - тестирует то что проект может работать в данном окружении, что у него есть все доступы к API, БД и т.д.  
> __Unittest__ является встроенной библиотекой, импортированной и Java'ого JUnit, поэтому у него интерфейс максимально дружелюбен к JUnit. Он не дружелюбен к PEP8, тестовые кейсы представлют собой классы; функционал не такой широкий как у Pytest.  
> __Pytest__ не является встроенной библиотекой, его надо устанавливать, т.е нужно проверять зависимость. Имеет широкий функционал, много батареек, удобная работа с фикстурами; очень гибкий, PEP8 фреднли, тестовые кейсы это файлы в которых атамарные кейсы это функции, а не класс.

- Что такое mock? Зачем нужен?
> Встроен в Unittest, в Pytest является отдельной батарейкой.
> Иногда нужно избежать каких-то вызовов, либо каких-то сайд эффектов, соответственно mock - это объект, который подменяет реальный объект и мы mock'у можем задать ожидаемое поведение, например: если вызывается mock, вместо реального объекта, то мы сразу возвращаем какой то результат, который мы можем просто ожидать. Mock'у тоже можно задать сайд-эффекты? чтобы он например один раз выводил результат, а второй раз выдавал ошибку, всё что угодно.  
> Нужен для избегания сайд-эффектов, избежать вызовов, которых мы не хотим. Нужно быть осторожным, чтобы mock не стал "божественным" объектом, чтобы не mock'ал всё что только можно.

- Что такое patching?
> patching - это когда мы подменяем какой то функционал на mock объект.

- Чем отличаются относительные импорты от абсолютных?
> __Абсолютный импорт__ предполагает полный путь, т. е. из корневой папки проекта к желаемому модулю. Абсолютный импорт указывает, что ресурс должен быть импортирован с использованием его полного пути из корневой папки проекта.
> Давайте посмотрим, что у нас есть следующая структура каталогов:
![image](https://github.com/graywhitew/interwievs/assets/40487026/dab3a907-5827-4011-9112-6bc18a94eb9f)
> Здесь каталог с именем project, в котором находятся два подкаталога, а именно pkg1, pkg2. pkg1 содержит два модуля, module1 и module2. pkg2 содержит три модуля: module3, module4, > > __init__.py и одно имя подпакета subpkg1, которое содержит module5.py .

> pkg1 / module1.py содержит функцию fun1  
> pkg2 / module3.py содержит функцию fun2  
> pkg2 / subpkg1 / module5.py содержат функцию fun3  
```python

# Python program showing
# practical example of
# absolute imports
 
# importing a fun1 from pkg1/module1
from pkg1.import module1 import fun1
 
from pkg1 import module2
 
# importing a fun2 from pkg2/module3
from pkg2 import module3 import fun2
 
# importing a fun3 from pkg2/subpkg1/module5
from pkg2.subpkg1.module5 import fun3
```
Относительный импорт определяет объект или модуль, импортированный из его текущего местоположения, то есть местоположения, в котором находится оператор import.
> Синтаксис относительного импорта зависит от текущего местоположения, а также от местоположения импортируемого модуля или объекта. Относительный импорт использует обозначение точки
> (.) для указания местоположения. Одна точка указывает, что модуль находится в текущем каталоге, две точки указывают, что модуль находится в родительском каталоге текущего
> местоположения, а три точки указывают, что он находится в директории прародителя и так далее.
```python

# Python program showing
# practical example of
# relative imports
 
# importing fun1 into pkg1/module1.py
from .module1 import fun1
 
# importing fun2 and fun3 into pkg2/module3.py
from .module3 import fun2
from .subpackage1.module5 import fun3
```
# Best practices
- SOLID, KISS, DRY, YANGI
> SOLID:  
>  S : Single Responsibility Principle (Принцип единственной ответственности) каждый класс должен выполнять только те цели, для которых он был задуман.  
>  O: Open-Closed Principle (Принцип открытости-закрытости) класс должен быть открыт для рассширения и закрыт для модификации(только через наследование).  
>  L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков) если у нас есть родительский и дочерний класс, и у нас есть функция умеющая работать с родительским классом, мы в эту функцию можем передать объект дочернего класса и это будет работать, потому что объект дочернего класс должен полностью уметь заменять родительский класс.  
>  I: Interface Segregation Principle (Принцип разделения интерфейса) чем иметь один огромный интерфейс под всё что только можно, лучше иметь много мелких интерфейсов под конкретные задачи.  
>  D: Dependency Inversion Principle (Принцип инверсии зависимостей) должны быть зависимости на классах, а не классы на зависимостях.  
> KISS - "Keep is simple, stupid" надо держать свои функции максимально простыми, чтобы они выполняли только то что нужно им, не более.  
> DRY - "Don't repeat your self" чем больше раз мы повторяем свой кодиарник, то если возникнет необъ. его модифицировать, то в n местах где мы его повторили n раз его надо будет промодифицировать, т.е. n вероятность ошибки, поэтому по хорошему повторяющийся код надо писать в одном месте выносить в функцию.  
> YAGNI - "You are gonna need it" в коде должен быть только тот функционал, который нужен тебе сейчас.  

- Какие паттерны проектирования знаешь? http://refactoring.guru/
> Делятся на три группы:
> __Порождающие__
> __Поведенческие__
> __Структурные__

- Conflict management

- SDLC

# Databases

- Что такое ORM? С какими работал?
> ORM - Object-relational mapping (Объектно-реляционное отображение) связывает наши объекты и классы с таблицами и строками на базе данных.  
> Какие знаешь? Django-ORM, SQLAlchemy, PonyORM.

- Какие NoSQL базы данных знаешь, с какими работал?
> Базы данных NoSQL созданы для работы с нереляционными данными  
> Плюсы: Гибкость; Простота разработки; Масштабирование;   
> MongoDB, Redis, RavenDB, Couchbase и т.д.  

- Какие SQL базы данных знаешь, с какими работал?
> MySQL и PostgreSQL.
> Какие отличия MySQL от PostgreSQL?  
> Отличие MySQL от PostgreSQL заключается в том, что первая система рассчитана на проекты с интенсивным чтением данных, для которых важна скорость и легкость управления, а вторая
> подходит для сложных запросов и работы с большими объемами информации (Big Data). У них разные подходы к хранению данных и их обработке, они отличаются производительностью
> и количеством поддерживаемых типов данных (в Postgre их больше).

- PK, FK
> PrimaryKey(первичный ключ) - уникальный ключ, который однозначно идентифицирует строку в таблице.  
> ForeignKey - ключ, использующийся для связи таблиц между друг другом.  
> Могут состоять из более чем одного столбца.  


- Типы связей? Как реализуется саязь много ко многим?
> Один к одному, один ко многим и многие ко многим.  
> Один к одному - связь, в которой есть две таблицы, первая с PrimaryKey, а вторая с ForeignKey, во второй таблице FK должен быть уникальным.
> Один ко многим - связь, в которой есть две таблицы, первая с PrimaryKey, а вторая с ForeignKey, во второй таблице FK должен быть неуникальным.
> Много ко многим - связь, в которой есть три таблицы, третья таблица является связующей, у которой есть ключ, как к первой так и ко второй, и она привязана к каждой связью один ко многим.

- Зачем нужны индексы?
> Если мы с каким то полем работаем часто и часто производим по нему поиск, то стоит завести индекс, тогда скорость работы с ним будет быстрее

- Зачем нужны триггеры?
> триггеры - event handlers, которыми служат какие то события и потом по этим событиям можно выполнять какие то действия, например слушаем обновление таблицы, и когда она обновилась мы поле update_date меняем на текущую дату.

- Что такое транзакция?
> Транзакция - блок операций (запрос к БД), в котором будут выполнены все операции, либо ниодной, но есть такие операции, которые неявно делают коммит транзакции(DROP TABLE, TRUNCATE TABLE, ALTER TABLE)

- ACID
> Atomicity — Атомарность | Транзакция не может быть зафиксированна частично, будет выполнена полностью  
> Consistency — Согласованность | Допустимость результатов данных  
> Isolation — Изолированность | Одна транзакция не может вклинуться в другую транзакцию  
> Durability — Надёжность | Если транзакция завершена, то результат зафиксирован в системе и ничего на это уже повлиять не может (никак внешний фактор)  

- Уровни изолированности транзакции

> __Read uncommitted__. Уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций.
На данном уровне нельзя использовать данные, на основе которых делаются важные для приложения выводы и критические решения т.к выводы эти могут быть далеки от реальности.
Данный уровень можно использовать, например, для примерных расчетов чего-либо. Результат COUNT(*) или MAX(*) можно использовать в каких-нибудь нестрогих отчетах.

>__ Read committed__. Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других транзакций. Таким образом, данный уровень обеспечивает защиту
> от грязного чтения.Это так называемые феномен неповторяющегося чтения, когда мы видим обновленные и удаленные строки (UPDATE, DELETE), и феномен чтения фантомов, когда мы видим
> добавленные записи (INSERT).

> __Repeatable read__. Уровень, позволяющий предотвратить феномен неповторяющегося чтения. Т.е. мы не видим в исполняющейся транзакции измененные и удаленные записи другой транзакцией. Но
> все еще видим вставленные записи из другой транзакции. Чтение фантомов никуда не уходит.

> __Serializable__. Уровень, при котором транзакции ведут себя как будто ничего более не существует, никакого влияния друг на друга нет. В классическом представлении этот уровень
> избавляет от эффекта чтения фантомов. Мы получаем максимальную согласованность данных, никакие лишние данные не зафиксируются. Цена за это медленная скорость транзакций из-за частых
> lock'ов поэтому при плохой архитектуре приложения это может сыграть с Вами злую шутку.

# Tools and Cloud
- Git
- Docker
- AWS

#WEB
-Веб-фраемворки
-REST (RESTful)
